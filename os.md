# 开发操作系统漫游


## 目录
- [环境准备](#环境准备)
    1. [linux系统](#linux操作系统)
    2. [gcc/g++](#gcc/g++)
    3. [qemu](#qemu)
    4. [nasm](#nasm)
- [前置知识](#前置知识)
    1. [浅谈](#浅谈)
    2. [linux下常用的命令](#linux下常用的命令)
    3. [gcc编译过程中发生了什么？](#gcc编译过程中发生了什么?)
    4. [关于汇编](#关于汇编)
    5. [make与Makefile](#make与Makefile)
    6. [gdb调试技能](#gdb调试技能)
- [从机器启动到操作系统的启动](#从机器启动到操作系统的启动)
    1. [浅谈i386的实模式与保护模式](#浅谈i386的实模式与保护模式)
    2. [bios与分区](#bios与分区)
    3. [bootloader的加载](#bootloader的加载)
    4. [内核的加载](#内核的加载)


## 环境准备

### linux操作系统

linux操作系统对于CS是绕不过去的一环,非常推荐大家使用,甚至是作为主力系统使用！
如果不会安装linux系统,那正好是一个动手学习的机会.在使用linux的过程中,或许会让你留下痛苦的回忆,但它们都会化为财富.
以下的示例全部使用ubuntu16.04为例.

### gcc/g++

gcc(**GNU Compiler Collection**) 是gnu开发的编程语言编译器,现在可以处理多种编程语言.我们需要它来完成对C语言以及部分汇编的编译工作.
ubuntu16.04是自带gcc的,版本为5.4.0
使用以下命令查看版本：
```shell
gcc --version
```

### qemu
qemu是一个开源仿真器,用于模拟一台计算机,可以用来运行我们编写的操作系统
使用以下命令进行安装：
```shell
sudo apt-get install qemu
```

### nasm
nasm为一种汇编器,用来编译汇编代码.
gcc自带的as对初学者可能更难一些.

## 前置知识

### 浅谈
操作系统可能是CS里最具有挑战性的一门课程了,在这门课程真的写一个操作系统还是非常困难的,但总是写一些东西总还是可以的.写这个东西一是为了在总结中进步,二是以后说不定也可以给别人做参考.
本次环境的选用在一定程度上参考了清华学堂在线课程的配置,也作出了一些变化
- 开发环境为：qemu+make+gcc+nasm+ubuntu16.04.
- 面向intel-i386开发,汇编使用intel格式

要完成一个操作系统,需要关注的知识点太多了.鉴于篇幅,个人的精力与能力,很多知识都只能简单的点一下.


### linux下常用的命令
我们对操作系统的控制的方式有两种,一种是常用的GUI式的（图形化界面）,另外一种是CLI（命令行）.一般我们将输入命令的地方称作shell,Terminal,终端,命令提示符.
无论是在windows下,或者linux,乃至OS X都是有命令行的,不过在具体的命令下有些差别的.这里只介绍最常用/必须要用到的命令.


```shell
ls      展示当前目录下的文件与目录
ls -a   展示所有文件（包括隐藏文件/文件夹)
ls -l   展示更详细的信息
```
```shell
cp  复制文件命令
mv  移动文件命令
rm  删除文件命令
cat 输出文件内容到终端
```
```shell
cd    切换目录命令
locate
find  查找文件命令
```
```shell
dd   用指定大小的块拷贝一个文件,并在拷贝的同时进行指定的转换.
```

具体的参数与使用方式,可以自行探索/在网上搜索

初学者可能要遇到的几个问题：

linux的权限问题
linux下的路径与windows是有区别的
linux安装软件的方式（在ubuntu下试用apt-get）


### gcc的编译过程中发生了什么


#### gcc的编译过程

使用以下代码作为示例.命名为hello.c
```c
//"hello.c"
#include<stdio.h>
int main(){
    printf("hello world"); //注释
    return 0;
}
```

打开终端,将位置切换至hello.c所在的文件夹.
使用以下命令
```shell
gcc hello.c
```
在这个文件夹下会生成a.out文件
终端内执行
```shell
./a.out
```
即可看到hello world的输出.

a.out为没有指定输出结果文件名时候的默认名,使用-o 可以指定文件名.以下命令可以看到生成了hello.out文件
```shell
gcc hello.c -o hello.out
```
---


gcc的编译过程整体上分为 预处理,编译,汇编,链接.

我们在调用gcc的时候,实际上是一步步完成,然后再删除了中间结果.

预处理的过程是除去注释以及展开宏.
头文件的引用就是在展开宏中完成的.

以下两个命令都会将预处理的结果输出到终端上.
```shell
gcc  -E hello.c 
cpp hello.c
```
使用-o 参数指定输出文件名
```shell
gcc -E hello.c -o hello.i
```

---

编译的过程是将预处理好的文件编译为汇编文件.
使用以下命令会生成一个hello.s的文件

```
gcc -S hello.i
```

gcc默认会使用AT&T格式的汇编,可以通过添加参数-masm=intel来指定为intel格式

---

汇编的过程是将汇编转化为二进制文件,不过此时的二进制文件还没有办法运行.详细参考后面多个文件连编的内容.
执行以下命令,会生成一个hello.o文件.又叫做可重定位文件.

```shell
gcc -c hello.s
as -o hello.o
```
---

链接之后就会生成可执行文件

```shell
gcc hello.o
```


----

使用-save-temps 参数可以保留中间的各种结果
```shell 
gcc -save-temps helloworld.c
```

#### 多个文件联合编译
有以下两个文件,分别命名为main.c与t1.c

```c
//main.c
#include<stdio.h>
int main(){
    int a=3,b=4;
    printf("%d",add(a,b));
    return 0;
}
```
```c
//t1.c
int add(int a,int b){
    return a+b;
}
```

使用以下两种命令编译的结果是相同的,执行./main.out会输出7
```shell
gcc main.c t1.c -o main.out
```

```shell
gcc -c main.c
gcc -c t1.c
gcc main.o t1.o -o main.out
```

第一种实际上是gcc帮我们做好了各种工作,第二个更能体现实际过程.多个源代码文件联合编译的过程实际上是各自生成他们的可重定位文件(.o文件) ,然后再将他们结合在一起.结合在一起的过程称作链接.我们调用的一些库函数(如printf)实际上也是有生成好的可重定位文件.


这方面还可以作更深入的了解,如有兴趣可以围绕下面学习.

elf头与符号表
链接的具体过程
静态链接与动态链接



### 关于汇编
汇编已经非常底层,毕竟对于我们来说,又不会自己造硬件.所以汇编已经是我们写的最底层的代码了.
关于汇编,随便说几个名字,或许你就会感觉很乱.
arm64,i386,arm,intel,amd,AT&T,x86,x86_64,IA-64,MIPS,RISC;
当然上述的东西有些对代码的完成并不影响,但对这些基本概念还是要有认识的.

1. CPU依靠指令来计算和控制系统,每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统.指令可以说就是机器语言.

2. 指令集就是处理器支持的指令的集合.常见的有arm指令集,x86指令集.它们也都有各自的版本.

3. 指令集架构(ISA)就像是特定处理器的设计图纸,规定了该类处理器支持哪些机器指令（指令集）、寄存器有哪些状态以及输入输出模型.它决定了处理器的实现.
常见的有CISC,RISC.一种是复杂指令集架构,一种是精简指令集架构.

4. 处理器可能支持多种指令集.

5. 微架构又称为微体系结构/微处理器体系结构.是具体的对一种指令集架构的实现方式.比如X86架构,amd64,IA64,Core(酷睿)等

6. 汇编语言是对机器语言的一种助记符.应用程序在切换硬件平台时,如果有汇编语言就需要重写.因为不同的硬件平台的支持的指令集是不同的.同一系列的指令集基本都是向前兼容的,升级后就也就是加入一些新的指令.

7. 汇编的书写格式分为intel格式与AT&T格式,gcc默认支持后者.这两种的差别可以查阅资料.

我们在写汇编代码的时候只需要关注希望运行平台支持的指令集就好了.
我们使用的就是intel汇编格式+面向i386处理器使用的指令集.

### make与Makefile
想一想gcc编译c语言代码的过程，针对小型项目，手动逐步编译倒也没有问题。但整个工程的架构逐渐变得复杂，数不清的源文件，又放在不同的目录中。就不能每次手动编译了。所以需要一个自动化编译的东西，这个东西就是make。对makefile做一个简单的讲述。

在项目的根目录下建立一个名为Makefile的文件写好相关内容，然后你只需要在终端中输入make命令，即可完成。

make的核心分为两个部分，即依赖关系与命令。

简单地说，就是会建立目标文件到若干依赖文件的依赖，当出现以下情况时，执行制定的命令。
1. 目标文件不存在
2. 依赖文件的更新时间晚于目标文件
3. 目标文件没有依赖文件

下面的是例子：
```makefile
main.out: main.cpp
    g++ main.cpp -o main.out
```
ps：命令有一个缩进，表示从属于上面的依赖关系。
如上的一个makefile文件，简单的说就是，当main.out不存在或者main.cpp比main.out新时执行下面的命令，重新生成了main.out。
怎么理解“新”呢：当你编译main.cpp 后，生成了main.out，main.out就比cpp新；然后你修改了main.cpp,main.cpp就比main.out新，新就证明被修改过。

makefile的第一个依赖关系的目标文件是整个makefile的目标文件，用上面写过的代码为例子
```c
//main.c
#include<stdio.h>
int add(int x,int y);
int main(){
    int a=3,b=4;
    printf("%d",add(a,b));
    return 0;
}
```
```c
//t1.c
int add(int x,int y){
    return x+y;
}
```


他的makefile可以写成（假设最终结果为main.out

```makefile
main.out: main.o t1.o
    gcc main.o add.o -o main.out
main.o: main.c
    gcc -c main.c
t1.o: t1.c
    gcc -c t1.c 
```

可以看出来，依赖可以是个树形结构，当一个文件被更新后，会逐层的更新相关的文件。第一个依赖关系是整个文件的目标文件。整个文件的目标文件的意思是执行make命令时的目标文件，也可以手动指定目标文件，比如： make main.o。不过这一点大多数时候是用来做以下情况的。

```makefile
clean:
    -rm -f  main.o t1.o main.out
```
ps：以上这段为上面的补充;减号的作用是发生错误时Makefile继续。
这样就可以执行make clean 来删除生成的文件了。

当然不仅仅是clean了，还有更多的用途比如写一个debug，自动执行debug的命令。

makefile还支持变量的使用来简化书写。并且可以在执行make的时候，手动指定变量的值。

如
```makefile
target:= main.o t1.o
main.out: main.o t1.o
    gcc $(target) -o main.out
main.o: main.c
    gcc -c main.c
t1.o: t1.c
    gcc -c t1.c 

.PHONY:clean
clean:
    -rm -f  $(target) main.out
```


makefile支持一隐含依赖规则。篇幅太长，不适合在这里说明。

伪目标的作用可以去了解一下，也不做说明。
当你看到如 .PHONY:clean 这样的东西要明白这是伪目标

makefile中还支持函数，我认为是make中比较难的一部分。

关于make，更多的规则可以自己在网上学习。
更多可以参考《跟我一起写makefile》一文，里面讲述的很全面。


### gdb调试技能


gdb是一个调试工具，比起很多ide提供的调试功能有些简陋。但是它麻雀虽小五脏俱全让人使用之后爱不释手。

事实上，我们只用其中的一小部分功能，就足够了。

```c
//"hello.c"
#include<stdio.h>
int main(){
    printf("hello world"); //注释
    return 0;
}
```

加入-g参数编译,使用gdb开始调试

```shell
gcc -g hello.c -o hello.out
gdb -q hello.out
```
gdb 的-q参数意思是不输出Copyright，不然会在进入的时候有一大段Copyright


命令|作用|示例
:----|:-----|:----
r |Run的缩写，如果此前没有下过断点，则执行完整个程序，否则暂停在第一个断点处
c|Continue的缩写，继续执行到下一个断点或程序结束。
b| 设置断点。可以使用行号，函数名称，地址等方式指定断点位置
d|指定编号的某个断点或所有断点
s,n，si,ni|单步执行，s进入函数内部，n不进入；si，ni汇编层次
p|print的缩写，显示指定变量的值。
display|设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示|
l|list的缩写查看源代码|
quit|退出|
help [命令名称]|帮助命令|


具体使用不详细介绍了，说一些重要的点

按下ctrl+x+a可以打开一个关键窗口，可以打开一个代码的显示窗口
调试的核心就是断点+单步执行+查看
print于和display非常有用，可以指定格式输出

---
下面说一说如何用gdb调试我们的操作系统
暂略




## 从机器启动到操作系统的启动

整个的启动过程大致可以分为以下几个阶段：
1. 上电后,机器进行初始化
2. 启动bios,选择启动设备
3. 在启动设备的相关位置加载 bootloader
4. bootloader加载内核

我们所需要关注的是后两个阶段.


### 浅谈硬件

对于整个系统的硬件组成,我们是不关系的.
我们这里要谈的是我们面向的硬件i386中的两种模式.


i386的cpu支持三种运行模式,分别为16位的实模式,32位的保护模式,虚拟8086模式(V86模式).

最后一种模式已经完全过时了,不用讲述,主要要说明的就是前两者.

8086具有16位的寄存器长度,我们称它为16位的处理器。它利用20位的地址总线+分段的方式,可以访问1MB的内存.但是只能分段进行,段的长度最大只能是64kb.8086只有一种工作模式.

从80286开始引入了保护模式的概念,虽然80286是16位处理器+24位地址总线.但在保护模式下,段寄存器中保存的不再是段地址,而是段选择子,真正的段地址位于段寄存器的描述符高速缓存中,是24位的。因此可以访问全部16MB内存。

80386 处理器的寄存器是 32 位的,而且拥有 32 根地址线,可以访问 2^32=4GB 的内存。


在刚加电时,自动处于实模式下.需要专门设置才能运行在保护模式下。

保护模式的好处:

- 确保应用程序无法对操作系统进行破坏
- 所有的地址总线都可以寻址,物理寻址空间大
- 支持内存分页机制，提供了对虚拟内存的良好支持。
- 保护模式下80386支持多任务，还支持优先级机制，不同的程序可以运行在不同的特权级上

具体保护模式的种种,相关的内容会在后面再谈.

ps:80x86的模式区分是历史遗留问题,为了向前兼容,而arm处理器就没有实模式.


### bios与分区


扇区,分区,GPT,uefi等....
暂略


### bootloader的加载

<!-- 上文提到了bios选择了启动项之后,便会将控制权交给相应的bootloader.

在进入bootloader后,有几件事情要做.
0x7c00h,实模式与保护模式,GDT表


Boot扇区在第0扇区,大小为512个Bytes.BIOS在识别Boot扇区时回去识别第511和512个Byte是不是0x55和0xaa,如果是这两个值就认定Boot扇区是有效的.所以这里需要讲最后两个Bytes填充为制定的Signature.
times伪指令用来填充0,至于填充多少个0,由当前地址来决定.$ - $$表示当前地址与当前首地址的差值.\$位当前地址,\$\$为块的首地址.用510 - (\$ - \$\$)就能得到需要填充的bytes数,填充完成后下一个byte就是第511个byte了.然后用dw 0xaa55来写入签名.由于用的是Little-endian,所以高地位必须对应,0x55 0xaa就是0xaa55了. -->
暂略



### 内核的加载

暂略